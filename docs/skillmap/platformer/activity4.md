# Multiple Levels

### @autoexpandOff true

```jres
{
    "transparency16": {
        "data": "hwQQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile1": {
        "data": "hwQQABAAAADMzMzMzMzMzLy7u7u7u7vLvMvMzMzMvMu8vMzMzMzLy7zMy8zMvMzLvMy8zMzLzMu8zMzLvMzMy7zMzLzLzMzLvMzMvMvMzMu8zMzLvMzMy7zMvMzMy8zLvMzLzMy8zMu8vMzMzMzLy7zLzMzMzLzLvLu7u7u7u8vMzMzMzMzMzA==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile2": {
        "data": "hwQQABAAAAAiIiIiIiIiIkJEREREREQkQiIiIiIiIiRCIiIiIiIiJEIiREQiIiIkQkJERCIkJCRCQiREJCQkJEJCREQiQiIkQkJERCRCIiRCQiREIiQkJEIiREQkJCQkQiIiIiIiIiRCIiIiIiIiJEIiIiIiIiIkQkRERERERCQiIiIiIiIiIg==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile3": {
        "data": "hwQQABAAAAB3d3d3d3d3d1dVVVVVVVV1V3d3d3d3d3VXd3d3d3d3dVdXVVVVVXd1V1dXV3d3d3VXV3VVd3d3dVdXV1d3d3d1V3d1dXV3d3VXd1VXdXd3dVd3dXV1d3d1V3dVVXV3d3VXd3d3d3d3dVd3d3d3d3d1V1VVVVVVVXV3d3d3d3d3dw==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile4": {
        "data": "hwQQABAAAABERERERERERFRVVVVVVVVFVEREREREREVURFRFRERERVRERVRERERFVFRVVUVEREVUVFVVVURFRVRUVVVVVUVFVFRVVVVVRUVUVFVVVURFRVRUVVVFRERFVERFVEREREVURFRFRERERVRERERERERFVFVVVVVVVUVERERERERERA==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "tile5": {
        "data": "hwQQABAAAACqqqqqqqqqqrq7u7u7u7uruqqqqqqqqqu6qqqqqqqqq7qqqqqqqqqruqqqqqqqqqu6qrurqqqqq7q6u7u7uqururq7u7u6q6u6qrurqqqqq7qqqqqqqqqruqqqqqqqqqu6qqqqqqqqq7qqqqqqqqqruru7u7u7u6uqqqqqqqqqqg==",
        "mimeType": "image/x-mkcd-f4",
        "tilemapTile": true
    },
    "level0": {
        "id": "level0",
        "mimeType": "application/mkcd-tilemap",
        "data": "MTAxZTAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDEwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMjIwMjIwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMDIwMjIyMjIyMjIwMjAwMDAwMjAwMDAyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMg==",
        "tileset": [
            "myTiles.transparency16",
            "myTiles.tile1",
            "myTiles.tile3",
            "myTiles.tile4",
            "myTiles.tile5"
        ],
        "displayName": "level0"
    },
    "level": {
        "id": "level",
        "mimeType": "application/mkcd-tilemap",
        "data": "MTAxZTAwMGEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDAwMDAwMDAwMDAwMDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAzMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAxMDEwMDAwMDEwNTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMTAxMDEwMTAxMDEwMTAxMDEwMDAwMDAwMDAwMDUwMDAwMDAwMDAwMDUwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAxMDEwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyMDAwMDIwMDAwMDAwMDAwMDAwMDAwMDIwMDAwMDAwMjAwMDAwMDAwMDAwMDAwMDAwMjIwMjIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDIwMjIyMjIyMjIwMjAwMDAwMDAwMDAyMDIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMg==",
        "tileset": [
            "myTiles.transparency16",
            "myTiles.tile1",
            "myTiles.tile3",
            "myTiles.tile4",
            "myTiles.tile5",
            "myTiles.tile2"
        ],
        "displayName": "platformer1"
    },
    "*": {
        "mimeType": "image/x-mkcd-f4",
        "dataEncoding": "base64",
        "namespace": "myTiles"
    }
}
```

```ghost
sprites.allOfKind(SpriteKind.Enemy)
currentLevel.fill(0)
for (let value of sprites.allOfKind(SpriteKind.Enemy)) {
    }
```

```template
scene.onOverlapTile(SpriteKind.Player, myTiles.tile2, function (sprite, location) {
    game.over(false)
})
scene.onOverlapTile(SpriteKind.Player, myTiles.tile4, function (sprite, location) {
    game.over(true)
})
controller.A.onEvent(ControllerButtonEvent.Pressed, function () {
    mySprite.vy = -200
})
sprites.onOverlap(SpriteKind.Player, SpriteKind.Enemy, function (sprite, otherSprite) {
    otherSprite.destroy()
    if (sprite.bottom < otherSprite.y) {
        sprite.vy = -100
    } else {
        info.changeLifeBy(-1)
    }
})
let myEnemy: Sprite = null
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
scene.cameraFollowSprite(mySprite)
info.setLife(3)
tiles.setTilemap(tilemap`level`)
tiles.placeOnRandomTile(mySprite, myTiles.tile3)
for (let value of tiles.getTilesByType(myTiles.tile5)) {
    myEnemy = sprites.create(img`
        a a a a a a a a a a a a a a a a
        a b b b b b b b b b b b b b b a
        a b a a a a a a a a a a a a b a
        a b a a b b a a a a b b a a b a
        a b a a a a b a a b a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a b a a a a b a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b a a a b b b b b b a a a b a
        a b a a b a a a a a a b a a b a
        a b a a a a a a a a a a a a b a
        a b a a a a a a a a a a a a b a
        a b b b b b b b b b b b b b b a
        a a a a a a a a a a a a a a a a
        `, SpriteKind.Enemy)
    tiles.placeOnTile(myEnemy, value)
    myEnemy.follow(mySprite, 30)
}


```

## Start @showdialog

This tutorial will help you add levels to your game.

To make level changes easier (and prevent having to write the same
code again and again) we'll also learn to create a simple [**_function_**](#funky "grouping of code that can be called using a specific name").

![Levels and Functions](/static/skillmap/platformer/platformer4.gif "And now for something completely different!  And a little bit the same.")


## Make a function

First, let's create a new function!

Functions are chunks of code that you can name and
[**_call_**](#callingYou "insert into your code using a named label")
over and over from inside your program.  Unlike loops, you can run the code inside a
function again and again, even if you're doing something else inbetween.

---


► In the toolbox, expand the **˅ Advanced** tab and click
on the ``||functions: Functions||`` category.

► Press the **[ Make a Function... ]** button to create your new function.

► Click inside the textbox to name this function **startNextLevel**, then click **Done**.

![naming a function](/static/skillmap/platformer/name-function.gif "Say my name, say my name.")


```blocks
function startNextLevel() {
}
```


## Refactoring pt. 1
Excellent! You should have a **startNextLevel** function container
in your workspace. Let's fill it up!

Right now, the code you need for starting a level lives inside the
``||loops: on start||`` container — we'll want to move it over to the function .

---


► Pull the ``||scene: set tilemap to [ ]||`` block out of ``||loops: on start||``.
Everything connected below should come along with it.

► Snap the whole chunk of code into your new **startNextLevel** function container.

---


**Voila! Now you have a function!**


```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
function startNextLevel () {
    tiles.setTilemap(tilemap`level`)
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }
}
```

## Refactoring pt. 2

Here's an important fact: *There's no point in building a function unless you
__call__ it somewhere in your program.*

The function that you've already built is just a
[**_definition_**](#defineMe "explanation of the meaning")
to let the computer know
which instructions to run when you call **startNextLevel** in your code.
The definition doesn't give the computer any idea *when* to run those
instructions.

Let's add a function call into our program to let the computer know
when to run **startNextLevel**.

---

► From the ``||functions: Functions||`` category, drag a
``||functions: call startNextLevel||`` block and snap it into the end of the
``||loops: on start||`` container.

---

Check your game on the game screen. It shouldn't feel any different than
the original (yet).

If it doesn't feel the same, take a look at the hint
to make sure your code matches up.

```blocks

function startNextLevel () {
    tiles.setTilemap(tilemap`level`)
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }
}

let myEnemy: Sprite = null
let currentLevel = 0
let mySprite: Sprite = null
scene.setBackgroundColor(11)
mySprite = sprites.create(img`
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 1 1 3 3 3 1 3
    3 1 3 3 1 3 3 1 3 3 1 3 3 3 1 3
    3 1 3 3 1 1 1 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 3 1 3 3 3 1 3
    3 1 3 3 1 3 3 3 3 1 1 1 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 3 3 3 3 3 3 3 3 3 3 3 3 1 3
    3 1 1 1 1 1 1 1 1 1 1 1 1 1 1 3
    3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
    `, SpriteKind.Player)
mySprite.ay = 500
controller.moveSprite(mySprite, 100, 0)
scene.cameraFollowSprite(mySprite)
info.setLife(3)
// @highlight
startNextLevel()
```

## Refactoring pt. 3

**🏆  Reach the trophy  🏆**

The trophy tile would make a perfect doorway to the next level.  We already
have an event for when the player overlaps that tile, we just need to change
what happens inside of it.

---

► Remove the ``||game: game over <WIN>||`` block from the
**on sprite overlaps 🏆** event
and replace it with a new ``||functions: call startNextLevel||`` block.


```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
scene.onOverlapTile(SpriteKind.Player, myTiles.tile4, function (sprite, location) {
   // @highlight
    startNextLevel()
})
function startNextLevel () {
    tiles.setTilemap(tilemap`level`)
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }
}
```

## Variable

**👾 Lots of great games have more than one level 👾**

If we want to be able to keep track of the level we're on and
recall that level whenever we need it, we're going to need
a variable.

A variable will let us use the placeholder **currentLevel**
to make decisions instead of creating new code for every possibility.

---


► To make a new variable, go to the ``||variables: Variables||`` menu
and click on ``||controller: Make a Variable...||`` .

► Enter **currentLevel** in the textbox and click **OK**.


## Variable 2

Now you have a variable named **currentLevel**.  Let's use it!

We'll need to [**_increment_**](#addOn "add to")
 **currentLevel** each time the **startNextLevel** function is called.

---


► Snap a ``||variables: change [currentLevel] by [1]||`` block
into the **top** of the **startNextLevel** function.


```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
    currentLevel += 1
    tiles.setTilemap(tilemap`level`)
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }

}
```

## Choosing a level pt. 1

If we want to change the scene for each new level (*spoiler...we do!*) then we're
going to need to add some logic that looks at the **currentLevel** variable
before it sets the stage.

This is the perfect place for another **if/then** element!

---

► Connect a new ``||logic: if <true> then||`` block near the **top** of
the **startNextLevel** function container, just below the block to **change currentLevel by 1** .


```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
    currentLevel += 1
    // @highlight
    if (true) {
    }
    tiles.setTilemap(tilemap`level`)
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }

}
```

## Choosing a level pt. 2

First, we should check and see if our current level is **1**.
If it is, we'll run the code for the first level,
using our original tilemap.

---


► Find a ``||logic:[0] [=] [0]||`` block to replace **`<true>`**
 in the empty ``||logic:if <true> then||`` container.

► Replace the first **0** in the logic arguement with  ``||variables(noclick):currentLevel||``.

► Replace the second **0** of the logic argument with **1**.


```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
    currentLevel += 1
    // @highlight
    if (currentLevel === 1) {
    }
    tiles.setTilemap(tilemap`level`)
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }
}
```

## Choosing a level pt. 3

💡  When restructuring a program, it's a good habit to make sure everything works
as expected before making it more complicated.

Let's get our **if/then** logic working with our current game before we add new levels.


---

If the player is on level 1, we want to show our current tile map.

► Move the ``||scene: set tilemap to [ ]||`` block from beneath the **if/then**
and snap it inside the empty container.

The connected code will travel with the ``||scene: set tilemap to [ ]||`` block,
so once it has been connected, you'll need to grab the rest of the code and
snap it back in place beneath the **if/then**.

```blocks

let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
    currentLevel += 1
    if (currentLevel === 1) {
        tiles.setTilemap(tilemap`level`)
    }
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }
}
```

## Choosing a level pt. 3.5

That's a great start...but to ensure that it's working the same way
as your original game, you'll need the player to win when they reach the trophy.

Let's think about how to do this with the conditional logic:
 - **IF** you're just starting and **currentLevel** is **1**, **THEN** put up the tilemap
 - Once we've reached the trophy, **currentLevel** is **bigger than 1**, and our player wins!

Thinking about it this way means we can use an **else** clause in our condition
to capture any case where **currentLevel** is larger than any level numbers we've
already defined.

---


► Press the **⊕** button on the **if/then** container to add an **else** clause.

► Snap a ``||game: game over <WIN>||`` block inside.

```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
    currentLevel += 1
    if (currentLevel === 1) {
        tiles.setTilemap(tilemap`level`)
    }
    else {
    // @highlight
        game.over(true)
    }
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }
}
```

## Choosing a level pt. 3

**❓❓ Ready to take this to another level ❓❓**

From here, adding new levels is extremely straightforward.  All you need to do is:
 - Add a new **else if** clause to your logic container
 - Copy the condition from your previous level into the new **else if**
 - Change the number on the right-side of the **=** to be the number of your new level
 - Set the new tilemap inside of the new **else if**

 That's it!  Ready to give it a shot?

---


► Press the **⊕** button on the **if/then/else** container to add an
**else if** clause.

► Duplicate the ``||logic:[currentLevel] [=] [1]||`` block and place the
copy in the new **else if** condition slot.

► Change **1** to **2**.

► Duplicate the ``||scene: set tilemap to [ ]||`` block from level 1 and snap it into the
empty **else if** container.



```block
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0

    if (currentLevel === 1) {
        tiles.setTilemap(tilemap`level`)
    }
    else if (currentLevel === 2) {
          tiles.setTilemap(tilemap`level`)

    }
    else {
        game.over(true)
    }


```

## Choosing a level pt. 4

**🎨 Time to get creative 🎨**

What would you like to add or remove from the tilemap for your second level?
Click on the tilemap icon inside the ``||scene: set tilemap to [ ]||`` block
and edit it until you've got something of your own.

Don't forget to leave a trophy tile in the new tilemap so the player has a way
to win!

You can follow those same steps to add a 3rd, 4th, or even 5th level!


## Enemy cleanup pt. 1

```ghost
sprites.allOfKind(SpriteKind.Enemy)
currentLevel.fill(0)
for (let value of sprites.allOfKind(SpriteKind.Enemy)) {
    }
```

**🎮 Try your game 🎮**

There may be a couple of hiccups with the level changes...for example, we
need to clean up enemies from the last level before loading a new one.

To do that, you'll need to go through your entire list of enemies and
destroy them one by one. Fortunately, Arcade has a block for this exact purpose.

---


► Snap a ``||loops: for element [value] of [list]||`` loop into the very **top**
 of the **startNextLevel** function.

► From the ``||sprites:Sprites||`` category, grab an ``||sprites:array of sprites of kind [Player]||``
 argument and replace the **list** variable in the header of your new loop.

► Change the **array of sprites** kind to **Enemy**.



```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
// @highlight
    for (let value of sprites.allOfKind(SpriteKind.Enemy)) {
    }
    currentLevel += 1
    if (currentLevel === 1) {
        tiles.setTilemap(tilemap`level`)
    }
    else if (currentLevel === 2) {
        tiles.setTilemap(tilemap`level`)
    }
    else {
        game.over(true)
    }
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }

}
```


## Enemy cleanup pt. 2

Now you have a loop that will focus on each enemy, one at a time.
This is your chance to destroy them!

---


► Drag a ``||sprites: destroy [mySprite]||`` block into the new **for element** loop.

► Replace ``||variables(noclick): mySprite||`` with the ``||variables(noclick): value||``
attribute from the header of the **for element** loop.

---


** Your game can have as many levels as you can imagine!**


```blocks
let myEnemy: Sprite = null
let mySprite: Sprite = null
let currentLevel = 0
function startNextLevel () {
// @highlight
    for (let value of sprites.allOfKind(SpriteKind.Enemy)) {
        value.destroy()
    }
    currentLevel += 1
    if (currentLevel === 1) {
        tiles.setTilemap(tilemap`level`)
    }
    else if (currentLevel === 2) {
        tiles.setTilemap(tilemap`level`)
    }
    else {
        game.over(true)
    }
    tiles.placeOnRandomTile(mySprite, myTiles.tile3)
    for (let value of tiles.getTilesByType(myTiles.tile5)) {
        myEnemy = sprites.create(img`
            a a a a a a a a a a a a a a a a
            a b b b b b b b b b b b b b b a
            a b a a a a a a a a a a a a b a
            a b a a b b a a a a b b a a b a
            a b a a a a b a a b a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a b a a a a b a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b a a a b b b b b b a a a b a
            a b a a b a a a a a a b a a b a
            a b a a a a a a a a a a a a b a
            a b a a a a a a a a a a a a b a
            a b b b b b b b b b b b b b b a
            a a a a a a a a a a a a a a a a
            `, SpriteKind.Enemy)
        tiles.placeOnTile(myEnemy, value)
        myEnemy.follow(mySprite, 30)
    }

}
```


##Finale
🔥 **That's it! Now give your game a try!** 🔥

Click **Done** to return to the main page where you can share your game
with family and friends!